/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import groovy.transform.EqualsAndHashCode
import groovy.transform.Sortable
import groovy.transform.ToString

@Sortable
@ToString
@EqualsAndHashCode
class Range {
    long start
    long end

    def boolean contains(long value) {
        return start <= value && value <= end
    }
}

def run(String[] args) {

    def TreeSet<Range> ranges = new TreeSet()
    def freshIdCount = 0
    def freshAvailableIdCount = 0
    
    def mergeRange = { Range inRange -> boolean
        for (range in ranges.headSet(new Range(start: inRange.start, end: Long.MAX_VALUE), true)) {
            if (inRange.start <= range.end && !inRange.is(range)) {
                range.end = Math.max(range.end, inRange.end)
                return true
            }
        }
        for (range in ranges.tailSet(new Range(start: inRange.start, end: inRange.start), true)) {
            if (range.start <= inRange.end && !inRange.is(range)) {
                range.start = inRange.start
                range.end = Math.max(range.end, inRange.end)
                return true
            }
        }
        return false
    }

    def addRange = { Range inRange ->
        if (!mergeRange(inRange)) {
            ranges << inRange   
        }
    }

    def readIntervals = { Reader reader ->
        while (true) {
            def String range = reader.readLine()
            if (range.isEmpty()) {
                return
            }
            def rangeValues = range.split("-")
            addRange(new Range(start: rangeValues[0] as long, end: rangeValues[1] as long))
        }
    }

    // Part one
    def countFreshIds = { Reader reader ->
        reader.eachLine { String id ->
            def idValue = id as long
            for (range in ranges.headSet(new Range(start: idValue, end: Long.MAX_VALUE), true)) {
                if (range.contains(idValue)) {
                    ++freshIdCount
                    break
                }                
            }
        }
    }

    // Part two
    def countFreshPossibleIds = {
        ranges.forEach {
            freshAvailableIdCount += it.end - it.start + 1
        }
    }

    def mergeIntervals = {
        def iterator = ranges.iterator()
        while (iterator.hasNext()) {
            if (mergeRange(inRange=iterator.next())) {
                iterator.remove()
            }            
        }
    }

    new File("../input").withReader { Reader reader ->
        readIntervals(reader)
        countFreshIds(reader)
        mergeIntervals()
        countFreshPossibleIds()
    }

    println "Fresh ID count: ${freshIdCount}"
    println "Fresh available ID count: ${freshAvailableIdCount}"
}

static void main(String[] args) {
    new org.example.App().run(args)
}
